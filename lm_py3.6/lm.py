# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _lm
else:
    import _lm

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _lm.delete_SwigPyIterator

    def value(self):
        return _lm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _lm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _lm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _lm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _lm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _lm.SwigPyIterator_copy(self)

    def next(self):
        return _lm.SwigPyIterator_next(self)

    def __next__(self):
        return _lm.SwigPyIterator___next__(self)

    def previous(self):
        return _lm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _lm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _lm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _lm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _lm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _lm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _lm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _lm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _lm:
_lm.SwigPyIterator_swigregister(SwigPyIterator)


def setVerbosityLevel(x):
    return _lm.setVerbosityLevel(x)
class stdVectorInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _lm.stdVectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _lm.stdVectorInt___nonzero__(self)

    def __bool__(self):
        return _lm.stdVectorInt___bool__(self)

    def __len__(self):
        return _lm.stdVectorInt___len__(self)

    def __getslice__(self, i, j):
        return _lm.stdVectorInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _lm.stdVectorInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _lm.stdVectorInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _lm.stdVectorInt___delitem__(self, *args)

    def __getitem__(self, *args):
        return _lm.stdVectorInt___getitem__(self, *args)

    def __setitem__(self, *args):
        return _lm.stdVectorInt___setitem__(self, *args)

    def pop(self):
        return _lm.stdVectorInt_pop(self)

    def append(self, x):
        return _lm.stdVectorInt_append(self, x)

    def empty(self):
        return _lm.stdVectorInt_empty(self)

    def size(self):
        return _lm.stdVectorInt_size(self)

    def swap(self, v):
        return _lm.stdVectorInt_swap(self, v)

    def begin(self):
        return _lm.stdVectorInt_begin(self)

    def end(self):
        return _lm.stdVectorInt_end(self)

    def rbegin(self):
        return _lm.stdVectorInt_rbegin(self)

    def rend(self):
        return _lm.stdVectorInt_rend(self)

    def clear(self):
        return _lm.stdVectorInt_clear(self)

    def get_allocator(self):
        return _lm.stdVectorInt_get_allocator(self)

    def pop_back(self):
        return _lm.stdVectorInt_pop_back(self)

    def erase(self, *args):
        return _lm.stdVectorInt_erase(self, *args)

    def __init__(self, *args):
        _lm.stdVectorInt_swiginit(self, _lm.new_stdVectorInt(*args))

    def push_back(self, x):
        return _lm.stdVectorInt_push_back(self, x)

    def front(self):
        return _lm.stdVectorInt_front(self)

    def back(self):
        return _lm.stdVectorInt_back(self)

    def assign(self, n, x):
        return _lm.stdVectorInt_assign(self, n, x)

    def resize(self, *args):
        return _lm.stdVectorInt_resize(self, *args)

    def insert(self, *args):
        return _lm.stdVectorInt_insert(self, *args)

    def reserve(self, n):
        return _lm.stdVectorInt_reserve(self, n)

    def capacity(self):
        return _lm.stdVectorInt_capacity(self)
    __swig_destroy__ = _lm.delete_stdVectorInt

# Register stdVectorInt in _lm:
_lm.stdVectorInt_swigregister(stdVectorInt)

class MESolver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register MESolver in _lm:
_lm.MESolver_swigregister(MESolver)

class point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, x=0.0, y=0.0, z=0.0):
        _lm.point_swiginit(self, _lm.new_point(x, y, z))
    x = property(_lm.point_x_get, _lm.point_x_set)
    y = property(_lm.point_y_get, _lm.point_y_set)
    z = property(_lm.point_z_get, _lm.point_z_set)

    def distanceSquared(self, p2):
        return _lm.point_distanceSquared(self, p2)

    def distance(self, p2):
        return _lm.point_distance(self, p2)
    __swig_destroy__ = _lm.delete_point

# Register point in _lm:
_lm.point_swigregister(point)

class bounding_box(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.bounding_box_swiginit(self, _lm.new_bounding_box(*args))
    min = property(_lm.bounding_box_min_get, _lm.bounding_box_min_set)
    max = property(_lm.bounding_box_max_get, _lm.bounding_box_max_set)

    def joinWith(self, j):
        return _lm.bounding_box_joinWith(self, j)
    __swig_destroy__ = _lm.delete_bounding_box

# Register bounding_box in _lm:
_lm.bounding_box_swigregister(bounding_box)

class vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, x=0.0, y=0.0, z=0.0):
        _lm.vector_swiginit(self, _lm.new_vector(x, y, z))
    x = property(_lm.vector_x_get, _lm.vector_x_set)
    y = property(_lm.vector_y_get, _lm.vector_y_set)
    z = property(_lm.vector_z_get, _lm.vector_z_set)
    __swig_destroy__ = _lm.delete_vector

# Register vector in _lm:
_lm.vector_swigregister(vector)

class Shape(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def boundingBoxesIntersect(self, query):
        return _lm.Shape_boundingBoxesIntersect(self, query)

    def intersects(self, query):
        return _lm.Shape_intersects(self, query)

    def contains(self, query):
        return _lm.Shape_contains(self, query)

    def getBoundingBox(self):
        return _lm.Shape_getBoundingBox(self)

    def getType(self):
        return _lm.Shape_getType(self)

    def getVolume(self):
        return _lm.Shape_getVolume(self)
    __swig_destroy__ = _lm.delete_Shape

# Register Shape in _lm:
_lm.Shape_swigregister(Shape)

class Sphere(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, center, radius, type):
        _lm.Sphere_swiginit(self, _lm.new_Sphere(center, radius, type))
    __swig_destroy__ = _lm.delete_Sphere

    def intersects(self, query):
        return _lm.Sphere_intersects(self, query)

    def contains(self, query):
        return _lm.Sphere_contains(self, query)

    def setCenter(self, center):
        return _lm.Sphere_setCenter(self, center)

    def getCenter(self):
        return _lm.Sphere_getCenter(self)

    def getRadius(self):
        return _lm.Sphere_getRadius(self)

# Register Sphere in _lm:
_lm.Sphere_swigregister(Sphere)

class Hemisphere(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, center, radius, orientation, type):
        _lm.Hemisphere_swiginit(self, _lm.new_Hemisphere(center, radius, orientation, type))
    __swig_destroy__ = _lm.delete_Hemisphere

    def intersects(self, query):
        return _lm.Hemisphere_intersects(self, query)

    def contains(self, query):
        return _lm.Hemisphere_contains(self, query)

    def getCenter(self):
        return _lm.Hemisphere_getCenter(self)

    def getRadius(self):
        return _lm.Hemisphere_getRadius(self)

    def getOrientation(self):
        return _lm.Hemisphere_getOrientation(self)

# Register Hemisphere in _lm:
_lm.Hemisphere_swigregister(Hemisphere)

class Capsule(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, p1, p2, radius, type):
        _lm.Capsule_swiginit(self, _lm.new_Capsule(p1, p2, radius, type))
    __swig_destroy__ = _lm.delete_Capsule

    def intersects(self, query):
        return _lm.Capsule_intersects(self, query)

    def contains(self, query):
        return _lm.Capsule_contains(self, query)

    def getP1(self):
        return _lm.Capsule_getP1(self)

    def getP2(self):
        return _lm.Capsule_getP2(self)

    def getRadius(self):
        return _lm.Capsule_getRadius(self)

# Register Capsule in _lm:
_lm.Capsule_swigregister(Capsule)

class Cylinder(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, p1, p2, radius, type):
        _lm.Cylinder_swiginit(self, _lm.new_Cylinder(p1, p2, radius, type))
    __swig_destroy__ = _lm.delete_Cylinder

    def intersects(self, query):
        return _lm.Cylinder_intersects(self, query)

    def contains(self, query):
        return _lm.Cylinder_contains(self, query)

    def getP1(self):
        return _lm.Cylinder_getP1(self)

    def getP2(self):
        return _lm.Cylinder_getP2(self)

    def getRadius(self):
        return _lm.Cylinder_getRadius(self)

# Register Cylinder in _lm:
_lm.Cylinder_swigregister(Cylinder)

class CapsuleShell(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, p1, p2, innerRadius, outerRadius, type):
        _lm.CapsuleShell_swiginit(self, _lm.new_CapsuleShell(p1, p2, innerRadius, outerRadius, type))
    __swig_destroy__ = _lm.delete_CapsuleShell

    def intersects(self, query):
        return _lm.CapsuleShell_intersects(self, query)

    def contains(self, query):
        return _lm.CapsuleShell_contains(self, query)

    def getP1(self):
        return _lm.CapsuleShell_getP1(self)

    def getP2(self):
        return _lm.CapsuleShell_getP2(self)

    def getInnerRadius(self):
        return _lm.CapsuleShell_getInnerRadius(self)

    def getOuterRadius(self):
        return _lm.CapsuleShell_getOuterRadius(self)

# Register CapsuleShell in _lm:
_lm.CapsuleShell_swigregister(CapsuleShell)

class Cuboid(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.Cuboid_swiginit(self, _lm.new_Cuboid(*args))
    __swig_destroy__ = _lm.delete_Cuboid

    def intersects(self, query):
        return _lm.Cuboid_intersects(self, query)

    def contains(self, query):
        return _lm.Cuboid_contains(self, query)

    def getP1(self):
        return _lm.Cuboid_getP1(self)

    def getP2(self):
        return _lm.Cuboid_getP2(self)

# Register Cuboid in _lm:
_lm.Cuboid_swigregister(Cuboid)

class Union(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, s1, s2, type):
        _lm.Union_swiginit(self, _lm.new_Union(s1, s2, type))
    __swig_destroy__ = _lm.delete_Union

    def intersects(self, query):
        return _lm.Union_intersects(self, query)

    def contains(self, query):
        return _lm.Union_contains(self, query)

# Register Union in _lm:
_lm.Union_swigregister(Union)

class Difference(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, s1, s2, type, symmetric=False):
        _lm.Difference_swiginit(self, _lm.new_Difference(s1, s2, type, symmetric))
    __swig_destroy__ = _lm.delete_Difference

    def intersects(self, query):
        return _lm.Difference_intersects(self, query)

    def contains(self, query):
        return _lm.Difference_contains(self, query)

# Register Difference in _lm:
_lm.Difference_swigregister(Difference)

class Intersection(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, s1, s2, type):
        _lm.Intersection_swiginit(self, _lm.new_Intersection(s1, s2, type))
    __swig_destroy__ = _lm.delete_Intersection

    def intersects(self, query):
        return _lm.Intersection_intersects(self, query)

    def contains(self, query):
        return _lm.Intersection_contains(self, query)

# Register Intersection in _lm:
_lm.Intersection_swigregister(Intersection)

class Torus(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.Torus_swiginit(self, _lm.new_Torus(*args))
    __swig_destroy__ = _lm.delete_Torus

    def intersects(self, query):
        return _lm.Torus_intersects(self, query)

    def contains(self, query):
        return _lm.Torus_contains(self, query)

    def setCenter(self, center):
        return _lm.Torus_setCenter(self, center)

    def getCenter(self):
        return _lm.Torus_getCenter(self)

    def getRadius1(self):
        return _lm.Torus_getRadius1(self)

    def getRadius2(self):
        return _lm.Torus_getRadius2(self)

# Register Torus in _lm:
_lm.Torus_swigregister(Torus)

class Ellipse(Shape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.Ellipse_swiginit(self, _lm.new_Ellipse(*args))
    __swig_destroy__ = _lm.delete_Ellipse

    def intersects(self, query):
        return _lm.Ellipse_intersects(self, query)

    def contains(self, query):
        return _lm.Ellipse_contains(self, query)

    def setCenter(self, center):
        return _lm.Ellipse_setCenter(self, center)

    def getCenter(self):
        return _lm.Ellipse_getCenter(self)

    def getRadius1(self):
        return _lm.Ellipse_getRadius1(self)

    def getRadius2(self):
        return _lm.Ellipse_getRadius2(self)

    def getRadius3(self):
        return _lm.Ellipse_getRadius3(self)

# Register Ellipse in _lm:
_lm.Ellipse_swigregister(Ellipse)

class LatticeBuilder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, xLen, yLen, zLen, collisionGridSpacing, seedTop, seedBottom):
        _lm.LatticeBuilder_swiginit(self, _lm.new_LatticeBuilder(xLen, yLen, zLen, collisionGridSpacing, seedTop, seedBottom))
    __swig_destroy__ = _lm.delete_LatticeBuilder

    def addRegion(self, shape):
        return _lm.LatticeBuilder_addRegion(self, shape)

    def placeSphere(self, position, radius, type):
        return _lm.LatticeBuilder_placeSphere(self, position, radius, type)

    def removeSphere(self, position, radius, type):
        return _lm.LatticeBuilder_removeSphere(self, position, radius, type)

    def placeRandomSphere(self, radius, type, region):
        return _lm.LatticeBuilder_placeRandomSphere(self, radius, type, region)

    def placeRandomSpheres(self, count, radius, type, region):
        return _lm.LatticeBuilder_placeRandomSpheres(self, count, radius, type, region)

    def fillWithRandomSpheres(self, volumeFraction, radius, type, region):
        return _lm.LatticeBuilder_fillWithRandomSpheres(self, volumeFraction, radius, type, region)

    def getSpatialModel(self, model):
        return _lm.LatticeBuilder_getSpatialModel(self, model)

    def addParticles(self, particleType, siteType, count):
        return _lm.LatticeBuilder_addParticles(self, particleType, siteType, count)

    def discretizeTo(self, lattice, obstacleSiteType, fractionObstacleSitesOccupied):
        return _lm.LatticeBuilder_discretizeTo(self, lattice, obstacleSiteType, fractionObstacleSitesOccupied)

# Register LatticeBuilder in _lm:
_lm.LatticeBuilder_swigregister(LatticeBuilder)

class DiffusionModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _lm.DiffusionModel_swiginit(self, _lm.new_DiffusionModel())

    def number_species(self):
        return _lm.DiffusionModel_number_species(self)

    def number_site_types(self):
        return _lm.DiffusionModel_number_site_types(self)

    def lattice_spacing(self):
        return _lm.DiffusionModel_lattice_spacing(self)

    def lattice_x_size(self):
        return _lm.DiffusionModel_lattice_x_size(self)

    def lattice_y_size(self):
        return _lm.DiffusionModel_lattice_y_size(self)

    def lattice_z_size(self):
        return _lm.DiffusionModel_lattice_z_size(self)

    def particles_per_site(self):
        return _lm.DiffusionModel_particles_per_site(self)

    def bytes_per_particle(self):
        return _lm.DiffusionModel_bytes_per_particle(self)

    def set_lattice_spacing(self, arg2):
        return _lm.DiffusionModel_set_lattice_spacing(self, arg2)

    def set_lattice_x_size(self, arg2):
        return _lm.DiffusionModel_set_lattice_x_size(self, arg2)

    def set_lattice_y_size(self, arg2):
        return _lm.DiffusionModel_set_lattice_y_size(self, arg2)

    def set_lattice_z_size(self, arg2):
        return _lm.DiffusionModel_set_lattice_z_size(self, arg2)

    def set_particles_per_site(self, arg2):
        return _lm.DiffusionModel_set_particles_per_site(self, arg2)

    def set_number_reactions(self, arg2):
        return _lm.DiffusionModel_set_number_reactions(self, arg2)

    def set_number_species(self, arg2):
        return _lm.DiffusionModel_set_number_species(self, arg2)

    def set_number_site_types(self, arg2):
        return _lm.DiffusionModel_set_number_site_types(self, arg2)

    def set_bytes_per_particle(self, arg2):
        return _lm.DiffusionModel_set_bytes_per_particle(self, arg2)

    def diffusion_matrix(self, arg2):
        return _lm.DiffusionModel_diffusion_matrix(self, arg2)

    def add_diffusion_matrix(self, arg2):
        return _lm.DiffusionModel_add_diffusion_matrix(self, arg2)

    def set_diffusion_matrix(self, arg2, arg3):
        return _lm.DiffusionModel_set_diffusion_matrix(self, arg2, arg3)

    def reaction_location_matrix(self, arg2):
        return _lm.DiffusionModel_reaction_location_matrix(self, arg2)

    def add_reaction_location_matrix(self, arg2):
        return _lm.DiffusionModel_add_reaction_location_matrix(self, arg2)

    def set_reaction_location_matrix(self, arg2, arg3):
        return _lm.DiffusionModel_set_reaction_location_matrix(self, arg2, arg3)
    __swig_destroy__ = _lm.delete_DiffusionModel

# Register DiffusionModel in _lm:
_lm.DiffusionModel_swigregister(DiffusionModel)

class ReactionModel_Reaction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _lm.ReactionModel_Reaction_swiginit(self, _lm.new_ReactionModel_Reaction())

    def type(self):
        return _lm.ReactionModel_Reaction_type(self)

    def set_type(self, arg2):
        return _lm.ReactionModel_Reaction_set_type(self, arg2)

    def rate_constant_size(self):
        return _lm.ReactionModel_Reaction_rate_constant_size(self)

    def add_rate_constant(self, arg2):
        return _lm.ReactionModel_Reaction_add_rate_constant(self, arg2)

    def set_rate_constant(self, arg2, arg3):
        return _lm.ReactionModel_Reaction_set_rate_constant(self, arg2, arg3)
    __swig_destroy__ = _lm.delete_ReactionModel_Reaction

# Register ReactionModel_Reaction in _lm:
_lm.ReactionModel_Reaction_swigregister(ReactionModel_Reaction)

class ReactionModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _lm.ReactionModel_swiginit(self, _lm.new_ReactionModel())

    def number_species(self):
        return _lm.ReactionModel_number_species(self)

    def set_number_species(self, arg2):
        return _lm.ReactionModel_set_number_species(self, arg2)

    def number_reactions(self):
        return _lm.ReactionModel_number_reactions(self)

    def set_number_reactions(self, arg2):
        return _lm.ReactionModel_set_number_reactions(self, arg2)

    def initial_species_count_size(self):
        return _lm.ReactionModel_initial_species_count_size(self)

    def add_initial_species_count(self, arg2):
        return _lm.ReactionModel_add_initial_species_count(self, arg2)

    def set_initial_species_count(self, arg2, arg3):
        return _lm.ReactionModel_set_initial_species_count(self, arg2, arg3)

    def reaction_size(self):
        return _lm.ReactionModel_reaction_size(self)

    def add_reaction(self):
        return _lm.ReactionModel_add_reaction(self)

    def reaction(self, arg2):
        return _lm.ReactionModel_reaction(self, arg2)

    def mutable_reaction(self, arg2):
        return _lm.ReactionModel_mutable_reaction(self, arg2)

    def add_stoichiometric_matrix(self, arg2):
        return _lm.ReactionModel_add_stoichiometric_matrix(self, arg2)

    def add_dependency_matrix(self, arg2):
        return _lm.ReactionModel_add_dependency_matrix(self, arg2)
    __swig_destroy__ = _lm.delete_ReactionModel

# Register ReactionModel in _lm:
_lm.ReactionModel_swigregister(ReactionModel)

class SpatialModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _lm.SpatialModel_swiginit(self, _lm.new_SpatialModel())
    __swig_destroy__ = _lm.delete_SpatialModel

# Register SpatialModel in _lm:
_lm.SpatialModel_swigregister(SpatialModel)

class SimulationFile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def isValidFile(filename):
        return _lm.SimulationFile_isValidFile(filename)

    @staticmethod
    def create(filename):
        return _lm.SimulationFile_create(filename)

    def __init__(self, filename):
        _lm.SimulationFile_swiginit(self, _lm.new_SimulationFile(filename))
    __swig_destroy__ = _lm.delete_SimulationFile

    def close(self):
        return _lm.SimulationFile_close(self)

    def getDiffusionModel(self, model):
        return _lm.SimulationFile_getDiffusionModel(self, model)

    def setDiffusionModel(self, diffusionModel):
        return _lm.SimulationFile_setDiffusionModel(self, diffusionModel)

    def getReactionModel(self, model):
        return _lm.SimulationFile_getReactionModel(self, model)

    def setReactionModel(self, reactionModel):
        return _lm.SimulationFile_setReactionModel(self, reactionModel)

    def getDiffusionModelLattice(self, m, lattice):
        return _lm.SimulationFile_getDiffusionModelLattice(self, m, lattice)

    def setDiffusionModelLattice(self, *args):
        return _lm.SimulationFile_setDiffusionModelLattice(self, *args)

    def getSpatialModel(self, model):
        return _lm.SimulationFile_getSpatialModel(self, model)

    def setSpatialModel(self, model):
        return _lm.SimulationFile_setSpatialModel(self, model)

    def getLatticeTimes(self, replicate):
        return _lm.SimulationFile_getLatticeTimes(self, replicate)

    def getLattice(self, replicate, latticeIndex, lattice):
        return _lm.SimulationFile_getLattice(self, replicate, latticeIndex, lattice)

    def getParameter(self, key):
        return _lm.SimulationFile_getParameter(self, key)

    def setParameter(self, k, v):
        return _lm.SimulationFile_setParameter(self, k, v)

    def getSpeciesCountTimes(self, replicate):
        return _lm.SimulationFile_getSpeciesCountTimes(self, replicate)

    def getSpeciesCounts(self, replicate):
        return _lm.SimulationFile_getSpeciesCounts(self, replicate)

    def getSpeciesNames(self):
        return _lm.SimulationFile_getSpeciesNames(self)

# Register SimulationFile in _lm:
_lm.SimulationFile_swigregister(SimulationFile)

def SimulationFile_isValidFile(filename):
    return _lm.SimulationFile_isValidFile(filename)

def SimulationFile_create(filename):
    return _lm.SimulationFile_create(filename)

class CMESolver(MESolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _lm.delete_CMESolver

    def initialize(self, replicate, parameters, resources):
        return _lm.CMESolver_initialize(self, replicate, parameters, resources)

    def getSpeciesCountView(self):
        return _lm.CMESolver_getSpeciesCountView(self)

    def getReactionRateConstantsView(self, reactionNumber):
        return _lm.CMESolver_getReactionRateConstantsView(self, reactionNumber)

# Register CMESolver in _lm:
_lm.CMESolver_swigregister(CMESolver)

class GillespieDSolver(CMESolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == GillespieDSolver:
            _self = None
        else:
            _self = self
        _lm.GillespieDSolver_swiginit(self, _lm.new_GillespieDSolver(_self, ))
    __swig_destroy__ = _lm.delete_GillespieDSolver

    def initialize(self, replicate, parameters, resources):
        return _lm.GillespieDSolver_initialize(self, replicate, parameters, resources)

    def needsReactionModel(self):
        return _lm.GillespieDSolver_needsReactionModel(self)

    def needsDiffusionModel(self):
        return _lm.GillespieDSolver_needsDiffusionModel(self)

    def generateTrajectory(self):
        return _lm.GillespieDSolver_generateTrajectory(self)

    def getSpeciesCountView(self):
        return _lm.GillespieDSolver_getSpeciesCountView(self)

    def getReactionRateConstantsView(self, reactionNumber):
        return _lm.GillespieDSolver_getReactionRateConstantsView(self, reactionNumber)

    def hookSimulation(self, time):
        return _lm.GillespieDSolver_hookSimulation(self, time)
    def __disown__(self):
        self.this.disown()
        _lm.disown_GillespieDSolver(self)
        return weakref.proxy(self)

# Register GillespieDSolver in _lm:
_lm.GillespieDSolver_swigregister(GillespieDSolver)

class NextReactionSolver(CMESolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == NextReactionSolver:
            _self = None
        else:
            _self = self
        _lm.NextReactionSolver_swiginit(self, _lm.new_NextReactionSolver(_self, *args))

    def initialize(self, replicate, parameters, resources):
        return _lm.NextReactionSolver_initialize(self, replicate, parameters, resources)
    __swig_destroy__ = _lm.delete_NextReactionSolver

    def needsReactionModel(self):
        return _lm.NextReactionSolver_needsReactionModel(self)

    def needsDiffusionModel(self):
        return _lm.NextReactionSolver_needsDiffusionModel(self)

    def generateTrajectory(self):
        return _lm.NextReactionSolver_generateTrajectory(self)

    def getSpeciesCountView(self):
        return _lm.NextReactionSolver_getSpeciesCountView(self)

    def getReactionRateConstantsView(self, reactionNumber):
        return _lm.NextReactionSolver_getReactionRateConstantsView(self, reactionNumber)

    def hookSimulation(self, time):
        return _lm.NextReactionSolver_hookSimulation(self, time)
    def __disown__(self):
        self.this.disown()
        _lm.disown_NextReactionSolver(self)
        return weakref.proxy(self)

# Register NextReactionSolver in _lm:
_lm.NextReactionSolver_swigregister(NextReactionSolver)


def getCompiledLatticeMaxOccupancy():
    return _lm.getCompiledLatticeMaxOccupancy()
class Lattice(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getMaxOccupancy(self):
        return _lm.Lattice_getMaxOccupancy(self)

    def getSize(self):
        return _lm.Lattice_getSize(self)

    def getXSize(self):
        return _lm.Lattice_getXSize(self)

    def getYSize(self):
        return _lm.Lattice_getYSize(self)

    def getZSize(self):
        return _lm.Lattice_getZSize(self)

    def getNumberSites(self):
        return _lm.Lattice_getNumberSites(self)

    def getSpacing(self):
        return _lm.Lattice_getSpacing(self)

    def getSiteType(self, x, y, z):
        return _lm.Lattice_getSiteType(self, x, y, z)

    def setSiteType(self, x, y, z, siteType):
        return _lm.Lattice_setSiteType(self, x, y, z, siteType)

    def getOccupancy(self, x, y, z):
        return _lm.Lattice_getOccupancy(self, x, y, z)

    def getParticle(self, x, y, z, particleIndex):
        return _lm.Lattice_getParticle(self, x, y, z, particleIndex)

    def findParticles(self, minParticleType, maxParticleType):
        return _lm.Lattice_findParticles(self, minParticleType, maxParticleType)

    def addParticle(self, x, y, z, particle):
        return _lm.Lattice_addParticle(self, x, y, z, particle)

    def removeParticles(self, x, y, z):
        return _lm.Lattice_removeParticles(self, x, y, z)

    def getParticleCounts(self):
        return _lm.Lattice_getParticleCounts(self)
    __swig_destroy__ = _lm.delete_Lattice

# Register Lattice in _lm:
_lm.Lattice_swigregister(Lattice)

class ByteLattice(Lattice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.ByteLattice_swiginit(self, _lm.new_ByteLattice(*args))
    __swig_destroy__ = _lm.delete_ByteLattice

    def getSiteType(self, x, y, z):
        return _lm.ByteLattice_getSiteType(self, x, y, z)

    def setSiteType(self, x, y, z, siteType):
        return _lm.ByteLattice_setSiteType(self, x, y, z, siteType)

    def getOccupancy(self, x, y, z):
        return _lm.ByteLattice_getOccupancy(self, x, y, z)

    def getParticle(self, x, y, z, particleIndex):
        return _lm.ByteLattice_getParticle(self, x, y, z, particleIndex)

    def findParticles(self, minParticleType, maxParticleType):
        return _lm.ByteLattice_findParticles(self, minParticleType, maxParticleType)

    def addParticle(self, x, y, z, particle):
        return _lm.ByteLattice_addParticle(self, x, y, z, particle)

    def removeParticles(self, x, y, z):
        return _lm.ByteLattice_removeParticles(self, x, y, z)

    def getParticleCounts(self):
        return _lm.ByteLattice_getParticleCounts(self)

    def getSiteLatticeView(self):
        return _lm.ByteLattice_getSiteLatticeView(self)

    def getParticleLatticeView(self):
        return _lm.ByteLattice_getParticleLatticeView(self)

# Register ByteLattice in _lm:
_lm.ByteLattice_swigregister(ByteLattice)

class IntLattice(Lattice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.IntLattice_swiginit(self, _lm.new_IntLattice(*args))
    __swig_destroy__ = _lm.delete_IntLattice

    def getSiteType(self, x, y, z):
        return _lm.IntLattice_getSiteType(self, x, y, z)

    def setSiteType(self, x, y, z, siteType):
        return _lm.IntLattice_setSiteType(self, x, y, z, siteType)

    def getOccupancy(self, x, y, z):
        return _lm.IntLattice_getOccupancy(self, x, y, z)

    def getParticle(self, x, y, z, particleIndex):
        return _lm.IntLattice_getParticle(self, x, y, z, particleIndex)

    def findParticles(self, minParticleType, maxParticleType):
        return _lm.IntLattice_findParticles(self, minParticleType, maxParticleType)

    def addParticle(self, x, y, z, particle):
        return _lm.IntLattice_addParticle(self, x, y, z, particle)

    def removeParticles(self, x, y, z):
        return _lm.IntLattice_removeParticles(self, x, y, z)

    def getParticleCounts(self):
        return _lm.IntLattice_getParticleCounts(self)

    def getSiteLatticeView(self):
        return _lm.IntLattice_getSiteLatticeView(self)

    def getParticleLatticeView(self, particleLattice, Nw, Nz, Ny, Nx, Np):
        return _lm.IntLattice_getParticleLatticeView(self, particleLattice, Nw, Nz, Ny, Nx, Np)

# Register IntLattice in _lm:
_lm.IntLattice_swigregister(IntLattice)

class CudaByteLattice(ByteLattice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.CudaByteLattice_swiginit(self, _lm.new_CudaByteLattice(*args))
    __swig_destroy__ = _lm.delete_CudaByteLattice

    def getParticleCounts(self):
        return _lm.CudaByteLattice_getParticleCounts(self)

    def getGPUMemorySrc(self):
        return _lm.CudaByteLattice_getGPUMemorySrc(self)

    def getGPUMemoryDest(self):
        return _lm.CudaByteLattice_getGPUMemoryDest(self)

    def swapSrcDest(self):
        return _lm.CudaByteLattice_swapSrcDest(self)

    def getGPUMemorySiteTypes(self):
        return _lm.CudaByteLattice_getGPUMemorySiteTypes(self)

# Register CudaByteLattice in _lm:
_lm.CudaByteLattice_swigregister(CudaByteLattice)

class CudaIntLattice(IntLattice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _lm.CudaIntLattice_swiginit(self, _lm.new_CudaIntLattice(*args))
    __swig_destroy__ = _lm.delete_CudaIntLattice

    def getGPUMemorySrc(self):
        return _lm.CudaIntLattice_getGPUMemorySrc(self)

    def getGPUMemoryDest(self):
        return _lm.CudaIntLattice_getGPUMemoryDest(self)

    def swapSrcDest(self):
        return _lm.CudaIntLattice_swapSrcDest(self)

    def getGPUMemorySiteTypes(self):
        return _lm.CudaIntLattice_getGPUMemorySiteTypes(self)

# Register CudaIntLattice in _lm:
_lm.CudaIntLattice_swigregister(CudaIntLattice)

class MpdRdmeSolver(MESolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MpdRdmeSolver:
            _self = None
        else:
            _self = self
        _lm.MpdRdmeSolver_swiginit(self, _lm.new_MpdRdmeSolver(_self, ))
    __swig_destroy__ = _lm.delete_MpdRdmeSolver

    def initialize(self, replicate, parameters, resources):
        return _lm.MpdRdmeSolver_initialize(self, replicate, parameters, resources)

    def needsReactionModel(self):
        return _lm.MpdRdmeSolver_needsReactionModel(self)

    def needsDiffusionModel(self):
        return _lm.MpdRdmeSolver_needsDiffusionModel(self)

    def generateTrajectory(self):
        return _lm.MpdRdmeSolver_generateTrajectory(self)

    def hookSimulation(self, time, lattice):
        return _lm.MpdRdmeSolver_hookSimulation(self, time, lattice)

    def writeLatticeSites(self, time, lattice):
        return _lm.MpdRdmeSolver_writeLatticeSites(self, time, lattice)
    def __disown__(self):
        self.this.disown()
        _lm.disown_MpdRdmeSolver(self)
        return weakref.proxy(self)

# Register MpdRdmeSolver in _lm:
_lm.MpdRdmeSolver_swigregister(MpdRdmeSolver)

class MGPUMpdRdmeSolver(MESolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MGPUMpdRdmeSolver:
            _self = None
        else:
            _self = self
        _lm.MGPUMpdRdmeSolver_swiginit(self, _lm.new_MGPUMpdRdmeSolver(_self, ))
    __swig_destroy__ = _lm.delete_MGPUMpdRdmeSolver

    def initialize(self, replicate, parameters, resources):
        return _lm.MGPUMpdRdmeSolver_initialize(self, replicate, parameters, resources)

    def needsReactionModel(self):
        return _lm.MGPUMpdRdmeSolver_needsReactionModel(self)

    def needsDiffusionModel(self):
        return _lm.MGPUMpdRdmeSolver_needsDiffusionModel(self)

    def generateTrajectory(self):
        return _lm.MGPUMpdRdmeSolver_generateTrajectory(self)

    def hookSimulation(self, time, lattice):
        return _lm.MGPUMpdRdmeSolver_hookSimulation(self, time, lattice)
    def __disown__(self):
        self.this.disown()
        _lm.disown_MGPUMpdRdmeSolver(self)
        return weakref.proxy(self)

# Register MGPUMpdRdmeSolver in _lm:
_lm.MGPUMpdRdmeSolver_swigregister(MGPUMpdRdmeSolver)


def runSimulation(simulationFilename, replicate, solverClass, cudaDevices, checkpointInterval):
    return _lm.runSimulation(simulationFilename, replicate, solverClass, cudaDevices, checkpointInterval)

def runSolver(simulationFilename, replicate, solver, cudaDevices, checkpointInterval):
    return _lm.runSolver(simulationFilename, replicate, solver, cudaDevices, checkpointInterval)


